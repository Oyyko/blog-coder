<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Oyyko</title>
    <link>https://blog.oyyko.com/</link>
    <description>Recent content on Oyyko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 07 Apr 2024 23:37:30 -0700</lastBuildDate>
    <atom:link href="https://blog.oyyko.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面试常见问题 1</title>
      <link>https://blog.oyyko.com/posts/interview1/</link>
      <pubDate>Sun, 07 Apr 2024 23:37:30 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/interview1/</guid>
      <description>部分内容为GPT的回答。&#xA;和红黑树的功能类似的还有哪些数据结构 Link to heading 红黑树是一种自平衡的二叉搜索树，它通过特定的属性和操作保持树的平衡，从而实现在最坏情况下仍能保持对数级别的查找、插入和删除时间复杂度。和红黑树提供相似功能的数据结构主要包括其他类型的自平衡二叉搜索树和一些特殊的数据结构，它们都能提供高效的查找、插入和删除操作。下面列出一些常见的例子：&#xA;AVL树 Link to heading AVL树是最早被发明的自平衡二叉搜索树之一。它严格保持二叉树的平衡，即任何节点的两个子树的高度最大差为1。这种严格的平衡要求使得AVL树在查找操作中表现得非常好，但在频繁的插入和删除操作中可能会有较多的旋转调整，相比于红黑树可能略显低效。&#xA;B树及其变种 Link to heading B树是一种平衡的多路搜索树，主要用于数据库和文件系统。B树通过将节点中存储多个元素并允许节点有多个子节点来减少树的高度，从而优化磁盘读写操作。B+树和B*树是B树的变种，它们在B树的基础上做了进一步的优化，广泛应用于数据库索引。&#xA;Splay树 Link to heading Splay树是一种自调整的二叉搜索树，它通过一种称为“伸展”的操作来保证最近进行的操作可以在较快的时间内完成。伸展树不保证树的严格平衡，但它能保证分摊的时间复杂度为O(log n)。&#xA;Treap Link to heading Treap是一种结合了二叉搜索树和堆的数据结构，节点既按键排序又按优先级堆组织。它利用旋转操作来维持二叉搜索树的性质和堆的性质，实现了平衡树的效果。&#xA;Skip List Link to heading 跳跃表是一种概率性的数据结构，通过在多层链表上添加“快速通道”来实现快速查找。虽然不是树结构，跳跃表在功能上与红黑树相似，提供了高效的查找、插入和删除操作，其平均时间和空间复杂度都是O(log n)。跳跃表的实现相比于红黑树和AVL树更为简单，易于理解和实现。&#xA;AA树 Link to heading AA树是一种变种的红黑树，它简化了红黑树的平衡规则和旋转操作。通过限制只有右链接可以是红色，AA树使得实现变得更加简单，同时保持了与红黑树相似的操作性能。&#xA;这些数据结构各有特点，适用于不同的场景。选择合适的数据结构需要根据实际的应用场景和性能要求来决定。&#xA;五千万个整数求和，尽量降低时间消耗。怎么做？ Link to heading 对于五千万个整数求和的问题，主要目标是优化时间复杂度和减少执行时间。以下是一些优化策略，可以帮助提高求和操作的效率：&#xA;1. 使用有效的数据结构 Link to heading 确保整数存储在连续的内存空间中，比如使用数组或列表，这样可以减少内存访问的开销。 2. 循环优化 Link to heading 尽可能使用高效的循环结构，减少循环内不必要的计算和条件判断。 3. 多线程或并行计算 Link to heading 利用现代计算机多核心的优势，可以将五千万个整数分成几个部分，每个核心处理一部分数据，然后将结果汇总。这种方式可以大大减少总的计算时间。 使用如OpenMP、Intel TBB（Thread Building Blocks）、Python的concurrent.futures模块或Java的java.util.concurrent包等并行框架和库来简化多线程编程的复杂性。 4. 向量化运算 Link to heading 在支持向量化的编程语言中（如使用NumPy库的Python），可以利用向量化运算来提高性能，因为这些运算是在底层进行优化的。 5.</description>
    </item>
    <item>
      <title>二分问题的统一解决方案</title>
      <link>https://blog.oyyko.com/posts/erfen/</link>
      <pubDate>Wed, 03 Apr 2024 16:10:24 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/erfen/</guid>
      <description>思路来自 https://www.youtube.com/watch?v=QvcM99na30k。本文为学习记录+结合自己的思考修改后得出的框架。&#xA;引入 Link to heading 在算法题中有时候会遇到这种场景，对于一个问题，它的答案是一个整数且一定取在一个范围内，例如答案只可能是$[1, 10^9]$中的一个数字。且存在一个条件，使得对于任何小于答案的数字，这个条件都不成立；而对于任何大于等于答案的数字，这个条件都成立。那么这个时候就可以使用二分的方法来找到答案。&#xA;框架与求解 Link to heading 下面用严格的语言来表达这类问题(我称为二分问题):&#xA;存在一个函数 check , 它接受一个整数 i 作为输入, 且 check(i) 只可能等于 True or False .&#xA;并且，存在一个数 $k$ ,使得对于任何小于 $k$ 的整数 i ，都有 check(i)==False ，而对于任何大于等于$k$的整数 i ，有 check(i)==True . 我们现在有函数 check ,需要找到这个整数$k$. 且我们知道 $k$ 在 $[a,b]$ 区间内。&#xA;我们接下来提出一个框架来解决这个问题。&#xA;首先，我们从获取信息的角度思考这个问题。在我们去实际跑一次 check 函数之前，我们是没有获取任何信息的。这个时候我们可以认为所有的 $[a,b]$ 之间的整数都是未知状态。&#xA;而我们在运行了 check(i) 之后，由于问题的性质，我们获取到的信息不只是 check(i) 本身为真还是假。而是可以知道一个范围内的所有整数都满足或者不满足条件。&#xA;例如我运行了 check(i) ,得到 check(i)==False. 那么我就知道对于所有的 $[a,i]$ 闭区间内的整数，它们check的结果一定也都是 False .&#xA;而如果我运行了 check(i) ,得到 check(i)==True.</description>
    </item>
    <item>
      <title>Go 并发与并行的区别</title>
      <link>https://blog.oyyko.com/posts/goconcnotpar/</link>
      <pubDate>Wed, 03 Apr 2024 15:12:33 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/goconcnotpar/</guid>
      <description></description>
    </item>
    <item>
      <title>Cpp 笔记 新系列1</title>
      <link>https://blog.oyyko.com/posts/cppnote1/</link>
      <pubDate>Tue, 02 Apr 2024 19:12:23 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/cppnote1/</guid>
      <description></description>
    </item>
    <item>
      <title>Go 学习笔记 1</title>
      <link>https://blog.oyyko.com/posts/go_note1/</link>
      <pubDate>Sun, 31 Mar 2024 14:07:47 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/go_note1/</guid>
      <description>ChatGPT摘抄 Link to heading Go和C++的区别 Link to heading Go语言（通常称为Golang）和C++在多个方面有显著的区别，包括它们的设计哲学、类型系统、内存管理、并发模型等方面。下面是一些主要的区别：&#xA;设计哲学:&#xA;Go 设计简洁，以提高开发效率和易用性为目标。它旨在使得编写高性能、可靠、易于维护的代码更加直接和简单。 C++ 设计为一种通用编程语言，强调性能和灵活性。它支持多种编程范式（如过程式、面向对象、泛型编程），但这也使得它变得相对复杂。 类型系统:&#xA;Go 有一个静态类型系统，但它的类型推导使得代码更简洁。它支持接口，但不支持类和继承，而是通过组合和接口实现多态和代码复用。 C++ 也是静态类型的，但它支持更复杂的类型系统，包括类、继承、模板等。这提供了强大的灵活性，但也增加了复杂性。 内存管理:&#xA;Go 提供自动垃圾收集，减少了内存泄漏的风险，简化了内存管理。 C++ 需要程序员手动管理内存，虽然提供了智能指针等现代特性来帮助管理，但管理不当仍可能导致内存泄漏和其他问题。 并发模型:&#xA;Go 的并发模型是其核心特性之一，基于“goroutines”（轻量级线程）和通道。这使得编写并发程序变得更简单和安全。 C++ 支持多线程，但并发并不是语言核心的一部分。C++11及以后的版本引入了一些并发编程的标准库支持，但使用起来比Go更复杂。 标准库和生态系统:&#xA;Go 有一个丰富的标准库，尤其是对于网络编程和并发编程。Go的生态系统随着语言的普及而快速增长，特别是在云服务和微服务开发中。 C++ 拥有庞大的第三方库和工具集，适用于各种编程任务，但标准库相对较小。C++在高性能计算、游戏开发、系统编程等领域有着悠久和广泛的应用。 编译和执行:&#xA;Go 编译器倾向于生成单个静态链接的二进制文件，简化了部署和分发。 C++ 通常需要更复杂的构建系统，尤其是对于依赖于多个库和平台的项目。 总之，Go和C++在设计上有根本的不同。Go旨在简化并发编程，提高开发效率，适合快速开发大型分布式系统。而C++提供了更多的控制和灵活性，适合那些需要极致性能优化和复杂系统设计的场景。选择哪种语言取决于项目需求、团队熟悉度和特定任务的需求。&#xA;讲一下go语言中的协程 Link to heading Go语言中的协程（goroutine）是Go语言并发设计的核心。goroutine 类似于线程，但在执行和资源消耗方面更为高效。它们由Go运行时（runtime）管理，而不是直接由操作系统管理。这样做的好处是goroutine的创建和销毁的成本比操作系统线程低得多，允许在同一程序中并发运行成千上万的goroutine。&#xA;创建goroutine Link to heading 在Go语言中，创建一个goroutine非常简单，只需要在函数调用前加上go关键字。例如：&#xA;1go funcName(params) 这会启动一个新的goroutine并在这个新的goroutine中调用funcName函数，params是传递给funcName函数的参数。&#xA;特点 Link to heading 轻量级：每个goroutine的堆栈大小在初始化时很小，根据需要可以动态地增长和缩减。这种设计让成千上万的goroutine并发运行成为可能。 不需要显式创建和销毁：goroutine由Go的运行时环境管理，程序员只需要创建它们，无需关心销毁和回收。 使用通道（channels）进行通信：goroutine之间的同步通常通过channels进行，channels是Go语言中的一种类型安全的消息传递机制。使用channels，可以很容易地在goroutine之间传递数据和信号。 示例 Link to heading 下面的示例展示了如何使用goroutine和channels进行并发编程：&#xA;1package main 2 3import ( 4 &amp;#34;fmt&amp;#34; 5 &amp;#34;time&amp;#34; 6) 7 8// 函数打印传入的消息 9func printMessage(message string) { 10 for i := 0; i &amp;lt; 5; i++ { 11 fmt.</description>
    </item>
    <item>
      <title>软件使用小技巧</title>
      <link>https://blog.oyyko.com/posts/trick/</link>
      <pubDate>Sat, 09 Mar 2024 20:01:37 -0800</pubDate>
      <guid>https://blog.oyyko.com/posts/trick/</guid>
      <description>Chrome Link to heading 如何在MacOS下使chrome全屏，并且是不显示tab栏和地址栏的真全屏？&#xA;首先Fn+F使它假全屏，之后按 ⌘ + ⇧ + F , (Command + Shift + F) 使得它真全屏.&#xA;Qemu Link to heading 按Option+Control+G 并不能release mouse。需要按下Option+Control+Command+G才可以。</description>
    </item>
    <item>
      <title>如何准备程序员面试</title>
      <link>https://blog.oyyko.com/posts/interview/</link>
      <pubDate>Thu, 07 Mar 2024 22:20:06 -0800</pubDate>
      <guid>https://blog.oyyko.com/posts/interview/</guid>
      <description>本文既讲解国内和北美面试中间的共同点，也对于两地不同的情况进行单独讲解。例如国内的八股文和北美的BQ。&#xA;本文主要面向的读者是还没参加过正式工作的学生群体。作者也没有跳槽或者高级别的工作经验。如有不合理、不详尽之处，请联系本人改正。十分感谢。&#xA;首先讲解一些互联网上常见的术语。本文可能用到其中的一些。如果你在本文阅读过程中看到看不懂的词语，请使用ctrl+F搜索。&#xA;术语表 Link to heading JD: (Job Description) 工作岗位描述&#xA;bar: 招人的标准。类似高考的分数线。一般用来形容难度高低。&#xA;DP: (data point) 数据点。一般含义就是指自己or身边朋友的例子。例如我GPA2.0被牛津录取了，我就可以在网上说，给大家贡献一个DP，GPA2.0被牛津录取。或者我在面试谷歌的过程中遇到了Leetcode1234这道题，我就可以说贡献一个DP，谷歌面试会考Leetcode1234.&#xA;OA: (Online Assessment) 在线笔试&#xA;BQ: (behavioral question) 和代码无关的问题。例如你在工作中遇到难题会怎么办？&#xA;VO: (Virtual Onsite) 电话或者视频面试。&#xA;HC: (Head Count) 人头数。也就是岗位计划招几个人。例如你面试了一个组，表现很好，但是他们这个组今年的hc只有1个人，而他们在面试你之前，已经签了1个人。那么这个时候由于hc不够，你就无法被录用。&#xA;CV/Resume: 简历&#xA;IC: (Individual Contributor) 个人贡献者，与之对应的是Manager。IC指的就是写代码的，Manager指的是管理岗位。&#xA;toxic: 有毒。往往用于形容令人不适的团队氛围或公司文化。&#xA;NG: (New Grad) 指刚毕业的学生。&#xA;ROI: (return on investment) 投资回报率&#xA;Skip: 你老板的老板。你也可以分别称呼他们为skip manager和 direct manager.&#xA;RA: (research assistant) 研究助理，你本科在实验室打杂也可以称自己做了2年的RA。&#xA;corner case: 写代码的时候遇到的极端or边界情况。&#xA;写在前面的话 Link to heading 心态 Link to heading 我们作为面试者，在求职的过程中，最终目标当然是拿到工作。因此很多时候你没有必要准备到万无一失了再投递简历或者面试。或者由于自己的不自信而不敢去投递或面试。哪怕心里很慌，也要先拿下offer再说。一般对于学生求职者来说，在拿到offer到正式上班中间还有好几个月的时间，如果你真的觉得自己不能胜任这份工作，那么你还有好几个月可以继续学习钻研相关领域。你如果总是想让自己的技术水平先达到高级工程师水平再去求职，那永远也准备不完。</description>
    </item>
    <item>
      <title>Projects</title>
      <link>https://blog.oyyko.com/projects/</link>
      <pubDate>Wed, 14 Feb 2024 14:44:17 -0800</pubDate>
      <guid>https://blog.oyyko.com/projects/</guid>
      <description>In chronological order, some of the projects I did, started from my freshman year. The source code of many older projects has been lost due to a laptop damage :(&#xA;N queens (2019) Link to heading Solving N queens problem (Just find one possible solution, not all situations) with the C programming language &amp;ndash; with high speed by using Heuristics Algorithm.&#xA;https://github.com/Oyyko/N-queens-in-C&#xA;This is my first project since college. So I was very impressed with it.</description>
    </item>
    <item>
      <title>UCSD CSE 230 Midterm Review Note</title>
      <link>https://blog.oyyko.com/posts/haskell1/</link>
      <pubDate>Wed, 01 Nov 2023 14:56:15 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/haskell1/</guid>
      <description>01-lambda Link to heading Programs are expressions e (also called λ-terms) of one of three kinds:&#xA;Variable x, y, z Abstraction (aka nameless function definition) (\x -&amp;gt; e) x is the formal parameter, e is the body “for any x compute e” Application (aka function call) (e1 e2) e1 is the function, e2 is the argument in your favorite language: e1(e2) Execute = rewrite step-by-step&#xA;Following simple rules until no more rules apply An variable x is free in e if there exists a free occurrence of x in e.</description>
    </item>
    <item>
      <title>Infra知识点</title>
      <link>https://blog.oyyko.com/posts/infra/</link>
      <pubDate>Wed, 11 Oct 2023 23:54:53 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/infra/</guid>
      <description>本文为摘录网络内容. 由于时间原因未记录原文地址，谷歌即可找到原文。&#xA;简述数据库三大范式 Link to heading 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。&#xA;数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，学号-&amp;gt;姓名，而专业编号-&amp;gt;专业名称，不满足数据库第二范式&#xA;数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。&#xA;简述MySQL的架构 Link to heading MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。&#xA;应用层：负责和客户端，响应客户端请求，建立连接，返回数据。&#xA;逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。&#xA;数据库引擎层：有常见的MyISAM,InnoDB等等。&#xA;物理层：负责文件存储，日志等等。&#xA;简述执行SQL语言的过程 Link to heading 客户端首先通过连接器进行身份认证和权限相关 如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。 没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。 通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。 执行语句，并从存储引擎返回数据。&#xA;简述MySQL的共享锁排它锁 Link to heading 共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。&#xA;简述MySQL中的按粒度的锁分类 Link to heading 表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。&#xA;行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。&#xA;Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。&#xA;Next-key Lock： 行锁+gap锁。&#xA;如何解决数据库死锁 Link to heading 预先检测到死锁的循环依赖，并立即返回一个错误。 当查询的时间达到锁等待超时的设定后放弃锁请求。&#xA;简述乐观锁和悲观锁 Link to heading 乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。&#xA;悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。&#xA;简述InnoDB存储引擎 Link to heading InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。</description>
    </item>
    <item>
      <title>New Macbook Setup</title>
      <link>https://blog.oyyko.com/posts/mac_config/</link>
      <pubDate>Wed, 04 Oct 2023 10:41:00 -0700</pubDate>
      <guid>https://blog.oyyko.com/posts/mac_config/</guid>
      <description>Install HomeBrew Link to heading see https://brew.sh/.&#xA;增加软件仓库 Link to heading 1brew tap homebrew/cask-fonts 2brew tap homebrew/cask 在增加了homebrew/cask之后，安装cask中的软件不需要brew install --cask, 只需要直接brew install即可。&#xA;但是官方不建议这么做，官方做法是使用brew install --cask XXX&#xA;Use homebrew to install Apps Link to heading 1## Install Rust CLI Apps 2brew install bat fd wget bottom lsd ripgrep 3## Install cask Apps 4brew install --cask google-chrome visual-studio-code wechat qq iterm2 iina Install snap Link to heading With Snap App, you can use Command ⌘ + 1 to call the first app in your dock.</description>
    </item>
    <item>
      <title>Mogan_note4</title>
      <link>https://blog.oyyko.com/posts/mogan_note4/</link>
      <pubDate>Sun, 03 Sep 2023 20:33:01 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/mogan_note4/</guid>
      <description>如何画曲线 Link to heading 1public: 2 inline curve_rep () {} 3 inline virtual ~curve_rep () {} 4 5 inline virtual int nr_components () { return 1; } 6 // the number of components of the curve is useful for getting 7 // nice parameterizations when concatenating curves 8 9 virtual point evaluate (double t)= 0; 10 // gives a point on the curve for its intrinsic parameterization 11 // curves are parameterized from 0.</description>
    </item>
    <item>
      <title>TeXmacs/Mogan Note 3</title>
      <link>https://blog.oyyko.com/posts/mogan_note3/</link>
      <pubDate>Wed, 02 Aug 2023 15:57:15 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/mogan_note3/</guid>
      <description>修改为两点画圆 Link to heading 研究三点画圆的代码实现&#xA;菜单中选择画圆的时候使用&#xA;1(&amp;#34;Circle&amp;#34; (graphics-set-mode &amp;#39;(edit carc))) 但是edit carc没有继续出现。因此推测是得到mode之后判断，如果第一个值是edit则统一处理，不需要分别处理。&#xA;以&#xA;1(tm-define (edit_right-button mode x y) 2 (:require (== mode &amp;#39;edit)) 3 (:state graphics-state) 4 (set-texmacs-pointer &amp;#39;graphics-cross) 5 (when current-obj 6 (graphics-delete))) 为例子。&#xA;它在这里被调用&#xA;1(tm-define (graphics-release-right x y) 2 ;;(display* &amp;#34;Graphics] Release-right &amp;#34; x &amp;#34;, &amp;#34; y &amp;#34;\n&amp;#34;) 3 (when (not (inside-graphical-text?)) 4 (edit_right-button (car (graphics-mode)) x y))) 可以看到确实是按照(car (graphics-mode))来进行调用。&#xA;研究如何通过菜单进行markup中的两点画圆&#xA;1(menu-bind graphics-focus-menu 2 (-&amp;gt; (eval (upcase-first (gr-mode-&amp;gt;string (graphics-mode)))) 3 (link graphics-mode-menu)) 4 (if (inside-graphical-over-under?</description>
    </item>
    <item>
      <title>About</title>
      <link>https://blog.oyyko.com/about/</link>
      <pubDate>Sat, 29 Jul 2023 23:43:28 +0800</pubDate>
      <guid>https://blog.oyyko.com/about/</guid>
      <description>Hi. Oyyko here. Nice to meet you!&#xA;One of my favorite Latin aphorisms is: “Memento mori”. It means remember you are mortal.&#xA;The name Oyyko was randomly typed by me. Since then, I have been using it as my nickname.&#xA;Some interesting things about me:&#xA;My OS: Windows7 → Windows10 → Manjaro → Ubuntu → Mac OS → Archlinux → Mac OS&#xA;My PC: HP laptop → Legion Y7000P → Macbook Pro 13&amp;rsquo; → ThinkPad X1 Carbon (9th) → mechrevo Code 01 → ITX desktop(12400 + Arc A770) → MacBook Pro 16&#39;</description>
    </item>
    <item>
      <title>Change0729</title>
      <link>https://blog.oyyko.com/posts/change0729/</link>
      <pubDate>Sat, 29 Jul 2023 22:50:19 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/change0729/</guid>
      <description>Now I changed the theme of this blog to https://github.com/luizdepra/hugo-coder.&#xA;Also I modified the theme a little to make it looks better.</description>
    </item>
    <item>
      <title>Vscode 返回上一个位置快捷键</title>
      <link>https://blog.oyyko.com/posts/vscode2/</link>
      <pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/vscode2/</guid>
      <description>非常有用的一个功能。&#xA;Windows: $Alt + \leftarrow$&#xA;Linux: $Control + Alt + -$</description>
    </item>
    <item>
      <title>Texmacs/Mogan Note 2</title>
      <link>https://blog.oyyko.com/posts/texmacs_note2/</link>
      <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/texmacs_note2/</guid>
      <description>23_15 Link to heading 1(get-init-tree &amp;#34;text-at-halign&amp;#34;) 这个与缓存有关。缓存位置在~/.Texmacs/。如果不更改缓存，更改源代码不会生效。&#xA;23_7 Link to heading 1(tm-define (graphics-release-left x y) 2 ;;(display* &amp;#34;Graphics] Release-left &amp;#34; x &amp;#34;, &amp;#34; y &amp;#34;\n&amp;#34;) 3 (if (inside-graphical-text?) 4 (with-innermost t graphical-text-context? 5 (let* ((ps (select-first (s2f x) (s2f y))) 6 (p (and ps (car ps)))) 7 (if (and p (list-starts? p (tree-&amp;gt;path t))) 8 (go-to p) 9 (tree-go-to t :start)))) 10 (edit_left-button (car (graphics-mode)) x y))) 1(tm-define (get-keyboard-modifiers) 2 the-keyboard-modifiers) 3 4(tm-define (set-keyboard-modifiers mods) 5 (set!</description>
    </item>
    <item>
      <title>Archlinux/Manjaro Install Guide</title>
      <link>https://blog.oyyko.com/posts/arch_install/</link>
      <pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/arch_install/</guid>
      <description>manjaro I3新电脑配置&#xA;假设已经安装好了manjaro i3，接下来要做的是：&#xA;基本装机 按顺序执行以下操作 Link to heading 换源 Link to heading 编辑/etc/pacman.d/mirrorlist 内容改为&#xA;1Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch 加入archlinuxcn源并安装yay Link to heading 在 /etc/pacman.conf 文件末尾添加以下两行&#xA;1[archlinuxcn] 2Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 之后通过以下命令安装 archlinuxcn-keyring 包导入 GPG key。&#xA;1sudo pacman -Sy archlinuxcn-keyring 之后就可以用yay 安装各种软件了&#xA;记得先sudo pacman -Syyu一下。&#xA;科学上网 Link to heading 由于安装某些软件的时候，yay会从国外下载，所以要先科学上网才能尽情安装想要的软件。&#xA;1yay -S clash-for-windows-bin 之后导入已有的订阅。 之后在终端中设置(例如加入到~/.zshrc中)：&#xA;1export https_proxy=http://127.0.0.1:7890; 2export http_proxy=http://127.0.0.1:7890; 3export all_proxy=socks5://127.0.0.1:7890; 对于i3wm等无法设置系统级代理的桌面环境，请把chrome的启动改为&#xA;1bindsym $mod+F2 exec google-chrome-stable --proxy-server=&amp;#34;socks5://127.0.0.1:7890&amp;#34; 这样chrome也可以自动使用代理上网了。&#xA;安装输入法 Link to heading 1yay -S fcitx5-im 2yay -S base-devel 3yay -S fcitx5-rime 4yay -S rime-cloverpinyin 配置fcitx5的环境变量：</description>
    </item>
    <item>
      <title>Texmacs Graphics Tutorial</title>
      <link>https://blog.oyyko.com/posts/texmacs_graphics_tutorial/</link>
      <pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/texmacs_graphics_tutorial/</guid>
      <description>原文：https://www.texmacs.org/tmweb/documents/tutorials/TeXmacs-graphics-tutorial.pdf</description>
    </item>
    <item>
      <title>Texmacs/Mogan Note</title>
      <link>https://blog.oyyko.com/posts/texmacs_note/</link>
      <pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/texmacs_note/</guid>
      <description>Note Link to heading graphics-utils.scm Link to heading 1;;These abbreviations are very convenient 2;;to use. A nice naming scheme is : 3;; 4;; -&amp;gt; b=bool ; 5;; -&amp;gt; i=integer ; 6;; -&amp;gt; f=float ; 7;; -&amp;gt; sy=symbol ; 8;; -&amp;gt; s=string ; 9;; -&amp;gt; o=Scheme object ; 10;; -&amp;gt; p=path. 11;; -&amp;gt; t=tree. 12;; 13;; One can add the missing ones on demand. 14(tm-define f2s float-&amp;gt;string) 15(tm-define s2f string-&amp;gt;float) 16(tm-define sy2s symbol-&amp;gt;string) 17(tm-define s2sy string-&amp;gt;symbol) 18(tm-define o2s object-&amp;gt;string) 19(tm-define s2o string-&amp;gt;object) 20(tm-define t2o tree-&amp;gt;object) 21(tm-define o2t object-&amp;gt;tree) graphics-single.</description>
    </item>
    <item>
      <title>Scheme Review 1</title>
      <link>https://blog.oyyko.com/posts/scheme/</link>
      <pubDate>Tue, 04 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/scheme/</guid>
      <description>https://courses.cs.washington.edu/courses/cse341/04wi/lectures/14-scheme-quote.html&#xA;Quote Link to heading Scheme has a convenient syntax for representing data literals: prefix any expression with &amp;rsquo; (single quote) and the expression, rather than being evaluated, will be returned as data:&#xA;1&amp;#39;3 ; =&amp;gt; 3 (a number) 2&amp;#39;&amp;#34;hi&amp;#34; ; =&amp;gt; &amp;#34;hi&amp;#34; (a string) 3&amp;#39;a ; =&amp;gt; a (a symbol) 4&amp;#39;(+ 3 4) ; =&amp;gt; (list &amp;#39;+ &amp;#39;3 &amp;#39;4) (a list) 5&amp;#39;(a b c) ; =&amp;gt; (list &amp;#39;a &amp;#39;b &amp;#39;c) (a list) 6 7&amp;#39;(define x 25) (a list) 8 ; =&amp;gt; (list &amp;#39;define &amp;#39;x &amp;#39;25) 9 ; =&amp;gt; (list &amp;#39;define &amp;#39;x 25) 10 11&amp;#39;(lambda (x) (+ x 3)) (a list) 12 ; =&amp;gt; (list &amp;#39;lambda (list &amp;#39;x) (list &amp;#39;+ &amp;#39;x &amp;#39;3)) 13 ; =&amp;gt; (list &amp;#39;lambda (list &amp;#39;x) (list &amp;#39;+ &amp;#39;x 3)) As these examples illustrate, &amp;ldquo;quoted&amp;rdquo; data remains unevaluated, and provides a convenient way of representing Scheme programs.</description>
    </item>
    <item>
      <title>In archlinux, chrome cannot be displayed normally under AMD.</title>
      <link>https://blog.oyyko.com/posts/chrome_amd/</link>
      <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/chrome_amd/</guid>
      <description>Solution:&#xA;1rm -rf .config/google-chrome/Default/GPUCache </description>
    </item>
    <item>
      <title>Value_categories_in_Cpp</title>
      <link>https://blog.oyyko.com/posts/value_categories_in_cpp/</link>
      <pubDate>Tue, 23 Aug 2022 15:20:51 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/value_categories_in_cpp/</guid>
      <description>Intro Link to heading 1#define IS_XVALUE(expr) \ 2(is_rvalue_reference&amp;lt;decltype((expr))&amp;gt;{}) 3#define IS_PRVALUE(expr) \ 4(!is_reference&amp;lt;decltype((expr))&amp;gt;{}) 5#define IS_LVALUE(expr) \ 6(is_lvalue_reference&amp;lt;decltype((expr))&amp;gt;{}) This is a method I recently discovered to determine which value category an expression is. I&amp;rsquo;ll explain why it works later.&#xA;First, let&amp;rsquo;s take a look at value categories in C++.&#xA;One of the most important things you should notice before you start is that value categories are not a property about values, but rather a property about expressions.</description>
    </item>
    <item>
      <title>Revisit_OS</title>
      <link>https://blog.oyyko.com/posts/revisit_os/</link>
      <pubDate>Sat, 20 Aug 2022 16:05:28 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/revisit_os/</guid>
      <description>For some reason, I&amp;rsquo;ve been reviewing OS related stuff lately.&#xA;hardlink and softlink Link to heading ln creates hark links. ln -s creates soft (a.k.a symbolic) links.&#xA;ln -l show the number of hardlinks points to the same inode.&#xA;hardlink points to the inode. softlink points to the path.&#xA;pros and cons: hardlink must be on the same partition, can only link to files. softlink can link to a file or directory, no partition limitation.</description>
    </item>
    <item>
      <title>Using Cpp17 or higher version of Cpp on Vscode extension Clangd</title>
      <link>https://blog.oyyko.com/posts/use-cpp17-on-vscode-clangd/</link>
      <pubDate>Sun, 07 Aug 2022 21:49:29 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/use-cpp17-on-vscode-clangd/</guid>
      <description>Recently I&amp;rsquo;ve switched my code completion tool in VScode from Microsoft&amp;rsquo;s official plugin to clangd. On the one hand, clangd can provide a better user experience, on the other hand, I also use this plugin in my company (Bytedance).&#xA;I joked to myself: Two of the most interesting things I learned when I interned at the company were that indentation changed from four spaces to two, and braces changed from wrap to no wrap.</description>
    </item>
    <item>
      <title>First Post</title>
      <link>https://blog.oyyko.com/posts/first-post/</link>
      <pubDate>Sun, 24 Jul 2022 00:37:35 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/first-post/</guid>
      <description>新博客 Link to heading 决定把博客切换到hugo。也算是人生路上一个新的开始。</description>
    </item>
    <item>
      <title>C&#43;&#43; Note 4</title>
      <link>https://blog.oyyko.com/posts/cpp4/</link>
      <pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/cpp4/</guid>
      <description>&lt;p&gt;C++ 笔记4&lt;/p&gt;</description>
    </item>
    <item>
      <title>BASH脚本</title>
      <link>https://blog.oyyko.com/posts/bash/</link>
      <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/bash/</guid>
      <description>&lt;p&gt;BASH 条件判断&lt;/p&gt;</description>
    </item>
    <item>
      <title>链接 Note 1</title>
      <link>https://blog.oyyko.com/posts/link1/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/link1/</guid>
      <description>&lt;p&gt;链接的笔记&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; Note 3</title>
      <link>https://blog.oyyko.com/posts/cpp3/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/cpp3/</guid>
      <description>&lt;p&gt;本文是我的C++笔记的第三篇&#xA;My Thrid C++ Note;&lt;/p&gt;</description>
    </item>
    <item>
      <title>位运算技巧</title>
      <link>https://blog.oyyko.com/posts/bithack/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/bithack/</guid>
      <description>&lt;p&gt;位运算技巧&lt;/p&gt;</description>
    </item>
    <item>
      <title>现代C&#43;&#43;白皮书 笔记1</title>
      <link>https://blog.oyyko.com/posts/cpp_whitepaper/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/cpp_whitepaper/</guid>
      <description>&lt;p&gt;现代C++白皮书 笔记1&lt;/p&gt;</description>
    </item>
    <item>
      <title>VsCode Latex 插件配置</title>
      <link>https://blog.oyyko.com/posts/vscode-latex/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/vscode-latex/</guid>
      <description>更改vscode的 setting.json文件 加入&#xA;1&amp;#34;latex-workshop.latex.tools&amp;#34;: [ 2 { 3 &amp;#34;name&amp;#34;: &amp;#34;latexmk&amp;#34;, 4 &amp;#34;command&amp;#34;: &amp;#34;latexmk&amp;#34;, 5 &amp;#34;args&amp;#34;: [ 6 &amp;#34;-synctex=1&amp;#34;, 7 &amp;#34;-interaction=nonstopmode&amp;#34;, 8 &amp;#34;-file-line-error&amp;#34;, 9 &amp;#34;-pdf&amp;#34;, 10 &amp;#34;-outdir=%OUTDIR%&amp;#34;, 11 &amp;#34;%DOC%&amp;#34;, 12 &amp;#34;-xelatex&amp;#34; 13 ], 14 &amp;#34;env&amp;#34;: {} 15 }, 即可&#xA;即在命令参数的最后增加 -xelatex 参数&#xA;备注：之前在文件头部添加% !TEX program = xelatex是管用的，现在不知道为啥又不行了。</description>
    </item>
    <item>
      <title>链表 笔记</title>
      <link>https://blog.oyyko.com/posts/linklist/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/linklist/</guid>
      <description>&lt;p&gt;链表笔记&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICS 笔记3</title>
      <link>https://blog.oyyko.com/posts/ics3/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/ics3/</guid>
      <description>&lt;p&gt;ICS笔记3&lt;/p&gt;</description>
    </item>
    <item>
      <title>压行技巧</title>
      <link>https://blog.oyyko.com/posts/yahang/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/yahang/</guid>
      <description>&lt;p&gt;压行技巧&lt;/p&gt;</description>
    </item>
    <item>
      <title>三道面试题</title>
      <link>https://blog.oyyko.com/posts/three-problem/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/three-problem/</guid>
      <description>&lt;p&gt;三道面试题&lt;/p&gt;</description>
    </item>
    <item>
      <title>数论笔记</title>
      <link>https://blog.oyyko.com/posts/shulun/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/shulun/</guid>
      <description>&lt;p&gt;本文是我的数论笔记的第一篇&#xA;关于:4k+1型和4k+3型素数&lt;/p&gt;</description>
    </item>
    <item>
      <title>二分总结</title>
      <link>https://blog.oyyko.com/posts/bisection/</link>
      <pubDate>Tue, 30 Nov 2021 15:20:51 +0800</pubDate>
      <guid>https://blog.oyyko.com/posts/bisection/</guid>
      <description>##　Leetcode 704 二分查找target&#xA;这种是在一个元素各不相同的有序数组里面找一个等于target的数 解法：&#xA;1class Solution 2{ 3public: 4 int search(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) 5 { 6 int l{0}; 7 int r = nums.size() - 1; 8 int mid; 9 while (l &amp;lt;= r) 10 { 11 mid = (l + (r - l) / 2); 12 if (nums[mid] == target) 13 { 14 return mid; 15 } 16 if (target &amp;lt; nums[mid]) 17 { 18 r = mid - 1; 19 } 20 else 21 { 22 l = mid + 1; 23 } 24 } 25 return -1; 26 } 27}; 此时，分三种情况。注意到，在不等于的时候，r和l都对mid有排斥</description>
    </item>
    <item>
      <title>C&#43;&#43; Note 2</title>
      <link>https://blog.oyyko.com/posts/cpp2/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/cpp2/</guid>
      <description>&lt;p&gt;本文是我的C++笔记的第二篇&#xA;My Second C++ Note;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICS PPT Note 1</title>
      <link>https://blog.oyyko.com/posts/ics_ppt/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/ics_ppt/</guid>
      <description>&lt;p&gt;计算系统概率PPT笔记1 复习期中&lt;/p&gt;</description>
    </item>
    <item>
      <title>A strange way to compute GCD</title>
      <link>https://blog.oyyko.com/posts/gcd/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/gcd/</guid>
      <description>&lt;p&gt;A strange way to compute GCD in one line&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICS Note 2</title>
      <link>https://blog.oyyko.com/posts/ics2/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/ics2/</guid>
      <description>&lt;p&gt;This is my notes for ICS. Source: book&#xA;计算系统概论笔记2 来自课本&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICS Note 1</title>
      <link>https://blog.oyyko.com/posts/ics1/</link>
      <pubDate>Wed, 17 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/ics1/</guid>
      <description>&lt;p&gt;This is my notes for ICS. Source: ppt&#xA;计算系统概论笔记1 来自PPT&lt;/p&gt;</description>
    </item>
    <item>
      <title>The language UNIMODAL is not context free</title>
      <link>https://blog.oyyko.com/posts/unimodal/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/unimodal/</guid>
      <description>&lt;p&gt;In this article, we will prove that: the language &amp;lsquo;UNIMODAL&amp;rsquo; is not cfg. Also, we will prove that cfg can not be used to compare binary number.&lt;/p&gt;</description>
    </item>
    <item>
      <title>VSCODE 使用笔记</title>
      <link>https://blog.oyyko.com/posts/vscode/</link>
      <pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/vscode/</guid>
      <description>&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>CCPC华为的一道趣题</title>
      <link>https://blog.oyyko.com/posts/ccpc_huawei/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/ccpc_huawei/</guid>
      <description>&lt;p&gt;本文记录了CCPC华为比赛中的一道题目&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fix a grub bug</title>
      <link>https://blog.oyyko.com/posts/grub/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/grub/</guid>
      <description>In this article, I will record how to fix the problem that grub can&amp;rsquo;t find Windows on nvme. So that someday, I can reuse this to help myself.&#xA;First of all, install os-prober.&#xA;Then, run update-grub or grub-mkconfig. Then you will find that os-prober is not working.&#xA;It will print a warning saying like: OS-PROBER will not be executed in order to protect xxx. If you want to know more, please look GRUB-DISABLE-OR-PROBER document to find more information.</description>
    </item>
    <item>
      <title>name and shakespeare</title>
      <link>https://blog.oyyko.com/posts/names_and_shakespeare/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/names_and_shakespeare/</guid>
      <description>匿名函数与莎士比亚大定理&#xA;This article is translated from Here&#xA;提问：为什么在lambda calculus里面，函数必须是匿名的。 Link to heading 我正在观看一个Youtube视频，在这个视频里面，讲者介绍了Y组合子的概念。 Y组合子概念产生的动机之一，正如讲者所述，是为了用lambda calculus来表示递归函数，以使得Church理论(任何能被实际上计算的东西都可以用lambda calculus来计算)保持成立。 我的问题在于：为什么我们不能通过名字来简单的调用一个函数。例如日常生活中我们经常会写下这种式子： $$ n(x,y)=x+y $$ 但是在lambda calculus里面我们不允许把这个函数与名字n相关联，我们只能匿名的定义它为 $$ (x,y)\rightarrow x+y $$ 为什么在lambda calculus里面我们不能拥有被命名的函数? 如果存在具名函数，我们会破坏什么准则? 或者仅仅是我搞错了视频的意思?&#xA;回答 Link to heading 关于这个问题的主要结论来自一个十六世纪晚期的英国数学家，他叫莎士比亚。他最著名的关于这个问题的论文名为《罗密欧与茱丽叶》，在1597年发表。&#xA;他的主要结论在第二幕的第二场景中阐明。即如下的著名定理：&#xA;名称有什么关系呢?玫瑰不叫玫瑰,依然芳香如故!&#xA;这个定理可以被直观的理解为&amp;quot;名字对意义毫无帮助&amp;quot; 莎士比亚的论文的大部分内容是一个用来补充定理的例子，用以表明名字尽管名字没有任何意义，但它们却是无穷无尽的问题的根源。 正如莎士比亚所指出的那样，名称可以在不改变含义的情况下进行更改，这一操作后来被丘奇及其追随者称为α转换。结果，如何确定名字表示的意义变成了造成了许许多多的问题。例如我们要发展“环境”的概念，在环境中名字-意义联系是确定的，并且发展出一系列的规则来辨别当前的环境。这使得计算机科学家们困惑了很长一段时间，引起了诸如臭名昭著的Funarg问题之类的技术难题。“环境”在许多流行的编程语言中仍然是个大问题，几乎和莎士比亚在其论文中提出的例子一样致命。 这个问题也与形式语言理论中提出的问题接近，即必须将字母和形式系统定义为同构，以便强调字母符号是抽象实体，而与它们如何作为某些集合中的元素而“实现”无关。 莎士比亚的主要结果也表明了科学随后即将与魔术和宗教告别。因为在魔术与宗教的世界里面，人们认为一个东西有它的“真名”。 所有这一切的结论是：尽管名字可以方便人们的日常工作和生活，但是在理论研究中不被名字而困扰更为重要。 记住：不是所有被叫做娘的都是你的母亲。&#xA;评论 Link to heading 最近，玫瑰正在被foobar所取代。</description>
    </item>
    <item>
      <title>C&#43;&#43; Note 1</title>
      <link>https://blog.oyyko.com/posts/cpp1/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/cpp1/</guid>
      <description>&lt;p&gt;本文是我的C++笔记的第一篇&#xA;My First C++ Note;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C Hello World Again</title>
      <link>https://blog.oyyko.com/posts/c_hello_world/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/c_hello_world/</guid>
      <description>&lt;p&gt;本文是我给地空学院的学生的C语言讲座的讲稿&lt;/p&gt;</description>
    </item>
    <item>
      <title>N queens Problem</title>
      <link>https://blog.oyyko.com/posts/n-queens/</link>
      <pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://blog.oyyko.com/posts/n-queens/</guid>
      <description>&lt;p&gt;This article will provide a fast way to find a solution for the famous N queens problem.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
